---
id: "2026-01-24-实现完整的-markdown-代码块渲染插件体系"
title: "前端集成现有渲染器 + 实现 Infographic 支持"
status: "in-progress"
created: "2026-01-24"
updated: "2026-01-24"
category: "implementation"
tags: ["frontend", "renderer", "vega", "graphviz", "infographic"]
---

# Issue: 前端集成现有渲染器 + 实现 Infographic 支持

## Goal

在前端 Markdown 渲染器中集成 Vega、Graphviz 和 Infographic，使所有代码块类型都能在浏览器中正确渲染。

## 背景/问题

### 架构现状

**服务端渲染器**（`plugins/` 目录）：
- ✅ `mermaid-renderer/` - 已实现
- ✅ `graphviz-renderer/` - 已实现
- ✅ `vega-renderer/` - 已实现
- ✅ `json-canvas-renderer/` - 已实现
- ✅ `office-renderer/` - 已实现
- ❌ `infographic-renderer/` - **未实现**

**前端渲染**（`src/client/components/editor/MarkdownRenderer.tsx`）：
- ✅ Mermaid - 已集成（直接使用 mermaid 库）
- ❌ Vega/Vega-Lite - **未集成**
- ❌ Graphviz/DOT - **未集成**
- ❌ Infographic - **未集成**

**浏览器原生支持**（不需要插件）：
- ✅ HTML - 浏览器原生支持
- ✅ SVG - 浏览器原生支持

### 问题分析

1. **服务端渲染器已存在**：Vega 和 Graphviz 的服务端渲染器已经实现，但前端没有集成
2. **Infographic 完全缺失**：服务端和前端都没有实现
3. **HTML/SVG 不需要插件**：浏览器原生支持，Markdown 中直接写即可

### 需求优先级

| 优先级 | 任务 | 说明 |
|:---:|------|------|
| 1 | 前端集成 Vega/Vega-Lite | 服务端已有，只需前端集成 |
| 2 | 前端集成 Graphviz/DOT | 服务端已有，只需前端集成 |
| 3 | 实现 Infographic 支持 | 服务端和前端都需要实现 |

## 验收标准 (Acceptance Criteria)

### Vega/Vega-Lite 前端集成
- [ ] WHEN 在 Markdown 中使用 `\`\`\`vega-lite` 代码块，系统 SHALL 在前端渲染为图表
- [ ] WHEN 在 Markdown 中使用 `\`\`\`vega` 代码块，系统 SHALL 在前端渲染为图表
- [ ] WHEN Vega 规范无效，系统 SHALL 显示友好的错误信息
- [ ] WHERE 主题切换时，系统 SHALL 自动更新图表主题

### Graphviz/DOT 前端集成
- [ ] WHEN 在 Markdown 中使用 `\`\`\`dot` 代码块，系统 SHALL 在前端渲染为图表
- [ ] WHEN DOT 语法错误，系统 SHALL 显示友好的错误信息
- [ ] WHERE 主题切换时，系统 SHALL 自动更新图表样式

### Infographic 完整实现
- [ ] WHEN 创建 `plugins/infographic-renderer/`，系统 SHALL 提供服务端渲染能力
- [ ] WHEN 在 Markdown 中使用 `\`\`\`infographic` 代码块，系统 SHALL 在前端渲染为信息图
- [ ] WHEN Infographic DSL 语法错误，系统 SHALL 显示友好的错误提示
- [ ] WHERE 渲染超时（>10秒），系统 SHALL 抛出超时错误

## 实施阶段

### Phase 1: 前端集成 Vega/Vega-Lite ✅ 优先级 1

#### 1.1 创建 remark 插件
- [ ] 创建 `src/parsers/remark-vega.ts`
  ```typescript
  // 处理 ```vega 和 ```vega-lite 代码块
  // 转换为带特殊标记的 HTML 结构
  ```

#### 1.2 在 MarkdownRenderer.tsx 中集成
- [ ] 导入 vega-embed 库
- [ ] 实现 `renderVegaDiagrams()` 函数（参考 `renderMermaidDiagrams()`）
- [ ] 添加主题支持（light/dark）
- [ ] 添加错误处理

#### 1.3 在 markdown.ts 中注册插件
- [ ] 在 `buildProcessor()` 中添加 `remarkVega` 插件

#### 1.4 测试
- [ ] 测试 vega-lite 基本图表
- [ ] 测试 vega 完整规范
- [ ] 测试主题切换
- [ ] 测试错误处理

### Phase 2: 前端集成 Graphviz/DOT ✅ 优先级 2

#### 2.1 创建 remark 插件
- [ ] 创建 `src/parsers/remark-dot.ts`
  ```typescript
  // 处理 ```dot 代码块
  // 转换为带特殊标记的 HTML 结构
  ```

#### 2.2 在 MarkdownRenderer.tsx 中集成
- [ ] 导入 @viz-js/viz 库
- [ ] 实现 `renderDotDiagrams()` 函数
- [ ] 添加主题支持
- [ ] 添加错误处理

#### 2.3 在 markdown.ts 中注册插件
- [ ] 在 `buildProcessor()` 中添加 `remarkDot` 插件

#### 2.4 测试
- [ ] 测试基本 DOT 图表
- [ ] 测试不同布局引擎（dot, neato, fdp, circo, twopi, osage）
- [ ] 测试主题切换
- [ ] 测试错误处理

### Phase 3: 实现 Infographic 支持 ✅ 优先级 3

#### 3.1 安装依赖
- [ ] 安装 @antv/infographic
  ```bash
  bun add @antv/infographic
  ```

#### 3.2 创建服务端渲染器
- [ ] 创建 `plugins/infographic-renderer/` 目录
- [ ] 实现 `InfographicRenderer.ts`（参考 VegaRenderer）
  - [ ] 实现 `render()` 方法
  - [ ] 实现事件驱动渲染
  - [ ] 实现超时处理（10秒）
  - [ ] 实现资源嵌入
  - [ ] 实现错误格式化
- [ ] 实现 `index.ts`（插件入口）
- [ ] 创建 `manifest.json`
- [ ] 编写 `README.md`

#### 3.3 创建 remark 插件
- [ ] 创建 `src/parsers/remark-infographic.ts`
  ```typescript
  // 处理 ```infographic 代码块
  // 转换为带特殊标记的 HTML 结构
  ```

#### 3.4 在 MarkdownRenderer.tsx 中集成
- [ ] 导入 @antv/infographic 库
- [ ] 实现 `renderInfographicDiagrams()` 函数
- [ ] 实现异步渲染和事件监听
- [ ] 添加超时处理
- [ ] 添加主题支持
- [ ] 添加错误处理

#### 3.5 在 markdown.ts 中注册插件
- [ ] 在 `buildProcessor()` 中添加 `remarkInfographic` 插件

#### 3.6 测试
- [ ] 测试基本信息图
- [ ] 测试不同信息图类型
- [ ] 测试超时机制
- [ ] 测试资源嵌入
- [ ] 测试错误处理

### Phase 4: 集成测试和优化
- [ ] 测试所有渲染器的协同工作
- [ ] 测试主题切换对所有图表的影响
- [ ] 性能测试和优化
- [ ] 内存泄漏检查
- [ ] 错误边界测试

### Phase 5: 文档和交付
- [ ] 更新 README.md
- [ ] 编写使用示例
- [ ] 更新技术文档
- [ ] 创建 PR
- [ ] 代码审查

## 关键决策

| 决策 | 理由 |
|------|------|
| 不实现 HTML/SVG 插件 | 浏览器原生支持，无需额外处理 |
| 复用服务端渲染器架构 | Vega 和 Graphviz 服务端已实现，前端只需集成 |
| 参考 Mermaid 的前端集成方式 | 已验证可行，保持代码风格一致 |
| Infographic 需要完整实现 | 服务端和前端都缺失，需要从零开发 |
| 使用异步渲染 | 避免阻塞 UI，提升用户体验 |
| 实现错误降级 | 渲染失败时显示错误信息而不是崩溃 |

## 技术实现细节

### 1. Vega/Vega-Lite 前端集成

**remark-vega.ts**:
```typescript
import type { Plugin } from 'unified';
import type { Root, Code } from 'mdast';
import { visit } from 'unist-util-visit';

export const remarkVega: Plugin<[], Root> = () => {
  return (tree) => {
    visit(tree, 'code', (node: Code) => {
      if (node.lang === 'vega' || node.lang === 'vega-lite') {
        (node as any).type = 'html';
        node.value = `<pre class="${node.lang}"><code>${escapeHtml(node.value)}</code></pre>`;
      }
    });
  };
};
```

**MarkdownRenderer.tsx 集成**:
```typescript
async function initVega() {
  if (typeof window === 'undefined') return;
  const vegaEmbed = (await import('vega-embed')).default;
  return vegaEmbed;
}

const renderVegaDiagrams = async () => {
  const vegaEmbed = await initVega();
  if (!vegaEmbed) return;

  const container = vegaRef.current;
  if (!container) return;

  // 查找所有 vega/vega-lite 代码块
  const vegaBlocks = container.querySelectorAll('pre.vega code, pre.vega-lite code');

  for (const block of Array.from(vegaBlocks)) {
    const code = block.textContent || '';
    const spec = JSON.parse(code);
    
    const div = document.createElement('div');
    block.parentElement?.replaceWith(div);
    
    await vegaEmbed(div, spec, {
      theme: theme === 'dark' ? 'dark' : 'default',
      actions: false,
    });
  }
};
```

### 2. Graphviz/DOT 前端集成

**remark-dot.ts**:
```typescript
export const remarkDot: Plugin<[], Root> = () => {
  return (tree) => {
    visit(tree, 'code', (node: Code) => {
      if (node.lang === 'dot' || node.lang === 'graphviz') {
        (node as any).type = 'html';
        node.value = `<pre class="dot"><code>${escapeHtml(node.value)}</code></pre>`;
      }
    });
  };
};
```

**MarkdownRenderer.tsx 集成**:
```typescript
async function initViz() {
  if (typeof window === 'undefined') return;
  const { instance } = await import('@viz-js/viz');
  return await instance();
}

const renderDotDiagrams = async () => {
  const viz = await initViz();
  if (!viz) return;

  const container = dotRef.current;
  if (!container) return;

  const dotBlocks = container.querySelectorAll('pre.dot code');

  for (const block of Array.from(dotBlocks)) {
    const code = block.textContent || '';
    
    const svg = viz.renderSVGElement(code);
    block.parentElement?.replaceWith(svg);
  }
};
```

### 3. Infographic 实现

**服务端渲染器**（参考 `plugins/vega-renderer/VegaRenderer.ts`）:
```typescript
export class InfographicRenderer implements RendererPlugin {
  readonly name = 'infographic';
  readonly extensions = ['.infographic'];
  readonly version = '1.0.0';

  async render(content: string, options?: Record<string, unknown>): Promise<string> {
    const Infographic = (await import('@antv/infographic')).default;
    
    return new Promise((resolve, reject) => {
      const timeout = setTimeout(() => {
        reject(new Error('Infographic render timeout after 10s'));
      }, 10000);

      const infographic = new Infographic({
        container: document.createElement('div'),
      });

      infographic.on('rendered', async () => {
        clearTimeout(timeout);
        const svg = await infographic.toDataURL({ 
          type: 'svg', 
          embedResources: true 
        });
        resolve(svg);
      });

      infographic.on('error', (err) => {
        clearTimeout(timeout);
        reject(new Error(formatErrorMessage(err)));
      });

      infographic.render(content);
    });
  }
}
```

**前端集成**（类似 Vega）:
```typescript
async function initInfographic() {
  if (typeof window === 'undefined') return;
  const Infographic = (await import('@antv/infographic')).default;
  return Infographic;
}

const renderInfographicDiagrams = async () => {
  const Infographic = await initInfographic();
  if (!Infographic) return;

  const container = infographicRef.current;
  if (!container) return;

  const infographicBlocks = container.querySelectorAll('pre.infographic code');

  for (const block of Array.from(infographicBlocks)) {
    const code = block.textContent || '';
    
    const div = document.createElement('div');
    block.parentElement?.replaceWith(div);
    
    const infographic = new Infographic({ container: div });
    
    await new Promise((resolve, reject) => {
      const timeout = setTimeout(() => reject(new Error('Timeout')), 10000);
      infographic.on('rendered', () => { clearTimeout(timeout); resolve(null); });
      infographic.on('error', (err) => { clearTimeout(timeout); reject(err); });
      infographic.render(code);
    });
  }
};
```

## 遇到的错误

| 日期 | 错误 | 解决方案 |
|------|------|---------|
| 2026-01-24 | 误以为需要实现 HTML/SVG 插件 | 确认浏览器原生支持，无需插件 |
| 2026-01-24 | 误以为需要创建新的服务端渲染器 | 确认 Vega 和 Graphviz 服务端已实现 |

## 相关资源

- [x] 参考实现: `src/client/components/editor/MarkdownRenderer.tsx` - Mermaid 前端集成
- [x] 参考实现: `src/parsers/remark-mermaid.ts` - Mermaid remark 插件
- [x] 服务端渲染器: `plugins/vega-renderer/` - Vega 服务端实现
- [x] 服务端渲染器: `plugins/graphviz-renderer/` - Graphviz 服务端实现
- [ ] 文档: [vega-embed](https://github.com/vega/vega-embed) - Vega 嵌入库
- [ ] 文档: [@viz-js/viz](https://github.com/viz-js/viz) - Graphviz WASM
- [ ] 文档: [@antv/infographic](https://github.com/antvis/infographic) - AntV 信息图库

## Notes

### 架构理解

1. **双层架构**：
   - **服务端**：`plugins/` 目录下的渲染器（用于 API 和文件处理）
   - **客户端**：`MarkdownRenderer.tsx` 中直接使用库（用于前端实时渲染）

2. **Mermaid 的实现模式**：
   - remark 插件：将 `\`\`\`mermaid` 转换为带标记的 HTML
   - 前端组件：查找标记的 HTML，使用 mermaid 库渲染
   - 主题支持：根据当前主题初始化 mermaid

3. **需要复用的模式**：
   - Vega 和 Graphviz 可以完全参考 Mermaid 的实现
   - Infographic 需要额外处理异步渲染和超时

### 实现优先级

1. **高优先级**：Vega/Vega-Lite（数据可视化常用）
2. **中优先级**：Graphviz/DOT（技术文档常用）
3. **低优先级**：Infographic（特定场景使用）

### 待确认事项

- [ ] Vega 和 Graphviz 的前端库是否已安装？
- [ ] 是否需要支持图表的交互功能？
- [ ] 是否需要支持图表导出功能？
- [ ] 缓存策略如何设计？

---

## Status 更新日志

- **2026-01-24 01:30**: 状态变更 → in-progress，备注: 完成架构分析，明确实施方案
- **2026-01-24 01:45**: 更新任务范围，备注: 确认不需要 HTML/SVG 插件，聚焦前端集成
